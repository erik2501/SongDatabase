/**
 *  Copyright (c) 2015, Facebook, Inc.
 *  All rights reserved.
 *
 *  This source code is licensed under the BSD-style license found in the
 *  LICENSE file in the root directory of this source tree. An additional grant
 *  of patent rights can be found in the PATENTS file in the same directory.
 */

'use strict';

var _slicedToArray = require('babel-runtime/helpers/sliced-to-array')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.missingFieldArgMessage = missingFieldArgMessage;
exports.missingDirectiveArgMessage = missingDirectiveArgMessage;
exports.badValueMessage = badValueMessage;
exports.defaultForNonNullArgMessage = defaultForNonNullArgMessage;
exports.badValueForDefaultArgMessage = badValueForDefaultArgMessage;
exports.undefinedFieldMessage = undefinedFieldMessage;
exports.fragmentOnNonCompositeErrorMessage = fragmentOnNonCompositeErrorMessage;
exports.inlineFragmentOnNonCompositeErrorMessage = inlineFragmentOnNonCompositeErrorMessage;
exports.unknownArgMessage = unknownArgMessage;
exports.unknownTypeMessage = unknownTypeMessage;
exports.undefinedVarMessage = undefinedVarMessage;
exports.undefinedVarByOpMessage = undefinedVarByOpMessage;
exports.unusedFragMessage = unusedFragMessage;
exports.unusedVariableMessage = unusedVariableMessage;
exports.typeIncompatibleSpreadMessage = typeIncompatibleSpreadMessage;
exports.typeIncompatibleAnonSpreadMessage = typeIncompatibleAnonSpreadMessage;
exports.noSubselectionAllowedMessage = noSubselectionAllowedMessage;
exports.requiredSubselectionMessage = requiredSubselectionMessage;
exports.nonInputTypeOnVarMessage = nonInputTypeOnVarMessage;
exports.cycleErrorMessage = cycleErrorMessage;
exports.unknownDirectiveMessage = unknownDirectiveMessage;
exports.misplacedDirectiveMessage = misplacedDirectiveMessage;
exports.badVarPosMessage = badVarPosMessage;
exports.fieldsConflictMessage = fieldsConflictMessage;

function missingFieldArgMessage(fieldName, argName, typeName) {
  return 'Field ' + fieldName + ' argument ' + argName + ' of type ' + typeName + ' is ' + 'required but not provided.';
}

function missingDirectiveArgMessage(directiveName, argName, typeName) {
  return 'Directive @' + directiveName + ' argument ' + argName + ' of type ' + (typeName + ' is required but not provided.');
}

function badValueMessage(argName, typeName, value) {
  return 'Argument ' + argName + ' expected type ' + typeName + ' but got: ' + value + '.';
}

function defaultForNonNullArgMessage(varName, typeName, guessTypeName) {
  return 'Variable $' + varName + ' of type ' + typeName + ' ' + 'is required and will never use the default value. ' + ('Perhaps you meant to use type ' + guessTypeName + '.');
}

function badValueForDefaultArgMessage(varName, typeName, value) {
  return 'Variable $' + varName + ' of type ' + typeName + ' has invalid default ' + ('value: ' + value + '.');
}

function undefinedFieldMessage(field, type) {
  return 'Cannot query field ' + field + ' on ' + type;
}

function fragmentOnNonCompositeErrorMessage(fragName, typeName) {
  return 'Fragment "' + fragName + '" cannot condition on non composite ' + ('type "' + typeName + '".');
}

function inlineFragmentOnNonCompositeErrorMessage(typeName) {
  return 'Fragment cannot condition on non composite type "' + typeName + '".';
}

function unknownArgMessage(argName, fieldName, typeName) {
  return 'Unknown argument ' + argName + ' on field ' + fieldName + ' ' + ('of type ' + typeName + '.');
}

function unknownTypeMessage(typeName) {
  return 'Unknown type ' + typeName + '.';
}

function undefinedVarMessage(varName) {
  return 'Variable $' + varName + ' is not defined.';
}

function undefinedVarByOpMessage(varName, opName) {
  return 'Variable $' + varName + ' is not defined by operation ' + opName + '.';
}

function unusedFragMessage(fragName) {
  return 'Fragment ' + fragName + ' is not used.';
}

function unusedVariableMessage(varName) {
  return 'Variable $' + varName + ' is not used.';
}

function typeIncompatibleSpreadMessage(fragName, parentType, fragType) {
  return 'Fragment "' + fragName + '" cannot be spread here as objects of ' + ('type "' + parentType + '" can never be of type "' + fragType + '".');
}

function typeIncompatibleAnonSpreadMessage(parentType, fragType) {
  return 'Fragment cannot be spread here as objects of ' + ('type "' + parentType + '" can never be of type "' + fragType + '".');
}

function noSubselectionAllowedMessage(field, type) {
  return 'Field "' + field + '" of type ' + type + ' must not have a sub selection.';
}

function requiredSubselectionMessage(field, type) {
  return 'Field "' + field + '" of type ' + type + ' must have a sub selection.';
}

function nonInputTypeOnVarMessage(variableName, typeName) {
  return 'Variable $' + variableName + ' cannot be non ' + ('input type ' + typeName + '.');
}

function cycleErrorMessage(fragmentName, spreadNames) {
  return 'Cannot spread fragment ' + fragmentName + ' within itself' + (spreadNames.length ? ' via ' + spreadNames.join(', ') + '.' : '.');
}

function unknownDirectiveMessage(directiveName) {
  return 'Unknown directive ' + directiveName + '.';
}

function misplacedDirectiveMessage(directiveName, placement) {
  return 'Directive ' + directiveName + ' may not be used on ' + placement + '.';
}

function badVarPosMessage(varName, varType, expectedType) {
  return 'Variable $' + varName + ' of type ' + varType + ' used in position expecting ' + ('type ' + expectedType + '.');
}

function fieldsConflictMessage(responseName, reason) {
  return 'Fields ' + responseName + ' conflict because ' + reasonMessage(reason) + '.';
}

function reasonMessage(reason) {
  if (Array.isArray(reason)) {
    return reason.map(function (_ref) {
      var _ref2 = _slicedToArray(_ref, 2);

      var responseName = _ref2[0];
      var subreason = _ref2[1];
      return 'subfields ' + responseName + ' conflict because ' + reasonMessage(subreason);
    }).join(' and ');
  }
  return reason;
}