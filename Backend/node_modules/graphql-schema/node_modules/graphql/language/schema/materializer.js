/**
 *  Copyright (c) 2015, Facebook, Inc.
 *  All rights reserved.
 *
 *  This source code is licensed under the BSD-style license found in the
 *  LICENSE file in the root directory of this source tree. An additional grant
 *  of patent rights can be found in the PATENTS file in the same directory.
 */

'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.materializeSchema = materializeSchema;

var _kinds = require('./kinds');

var _type = require('../../type');

var _ast = require('./ast');

var _executorValues = require('../../executor/values');

var _kinds2 = require('../kinds');

function nullish(obj) {
  return obj === null || obj === undefined;
}

/**
 * Takes the array of N elements constructs an object.
 * For each elemenet sets obj[keyFnArg(e}] = valueFnArg
 * If they are not specified they default to the identity function
 */
function makeDict(array, keyFnArg, valueFnArg) {
  var map = {};
  var keyFn = nullish(keyFnArg) ? function (t) {
    return t;
  } : keyFnArg;
  var valueFn = nullish(valueFnArg) ? function (t) {
    return t;
  } : valueFnArg;
  array.forEach(function (item) {
    map[keyFn(item)] = valueFn(item);
  });
  return map;
}

function buildWrappedType(innerType, inputTypeAST) {
  if (inputTypeAST.kind === _kinds2.LIST_TYPE) {
    return new _type.GraphQLList(buildWrappedType(innerType, inputTypeAST.type));
  }
  if (inputTypeAST.kind === _kinds2.NON_NULL_TYPE) {
    return new _type.GraphQLNonNull(buildWrappedType(innerType, inputTypeAST.type));
  }
  return innerType;
}

function getInnerTypeName(_x) {
  var _again = true;

  _function: while (_again) {
    var typeAST = _x;
    _again = false;

    if (typeAST.kind === _kinds2.LIST_TYPE || typeAST.kind === _kinds2.NON_NULL_TYPE) {
      _x = typeAST.type;
      _again = true;
      continue _function;
    }
    return typeAST.name.value;
  }
}

/**
 * This takes the ast of a schema document produced by parseSchema in
 * src/language/schema/parser.js.
 *
 * Given that AST it constructs a GraphQLSchema. As constructed
 * they are not particularly useful for non-introspection queries
 * since they have no resolve methods.
 */

function materializeSchema(ast, queryTypeName, mutationTypeName) {

  if (nullish(ast)) {
    throw new Error('must pass in ast');
  }
  if (nullish(queryTypeName)) {
    throw new Error('must pass in query type');
  }

  var astMap = makeDict(ast.definitions, function (d) {
    return d.name.value;
  });

  if (nullish(astMap[queryTypeName])) {
    throw new Error('Specified query type ' + queryTypeName + ' not found in document.');
  }

  /**
   * This generates a function that allows you to produce
   * type definitions on demand. We produce the function
   * in order to close over the memoization dictionaries
   * that need to be retained over multiple functions calls.
   **/
  function getTypeDefProducer() {

    var innerTypeMap = {
      String: _type.GraphQLString,
      Int: _type.GraphQLInt,
      Boolean: _type.GraphQLBoolean,
      ID: _type.GraphQLID
    };

    return function (typeAST) {
      var typeName = getInnerTypeName(typeAST);
      if (!nullish(innerTypeMap[typeName])) {
        return buildWrappedType(innerTypeMap[typeName], typeAST);
      }

      if (nullish(astMap[typeName])) {
        throw new Error('Type ' + typeName + ' not found in document');
      }

      var innerTypeDef = makeSchemaDef(astMap[typeName]);
      if (nullish(innerTypeDef)) {
        throw new Error('Nothing constructed for ' + typeName);
      }
      innerTypeMap[typeName] = innerTypeDef;
      return buildWrappedType(innerTypeDef, typeAST);
    };
  }

  var produceTypeDef = getTypeDefProducer(ast);

  if (nullish(astMap[queryTypeName])) {
    throw new Error('Type ' + queryTypeName + ' not found in document');
  }

  var queryType = produceTypeDef(astMap[queryTypeName]);
  var schema;
  if (nullish(mutationTypeName)) {
    schema = new _type.GraphQLSchema({ query: queryType });
  } else {
    schema = new _type.GraphQLSchema({
      query: queryTypeName,
      mutation: produceTypeDef(astMap[mutationTypeName])
    });
  }

  // This actually constructs all the types by iterating over the schema
  // This makes it so that errors actually get caught before this function
  // exits.
  schema.getTypeMap();
  return schema;

  function makeSchemaDef(def) {
    if (nullish(def)) {
      throw new Error('def must be defined');
    }
    switch (def.kind) {
      case _kinds.TYPE_DEFINITION:
        return makeTypeDef(def);
      case _kinds.INTERFACE_DEFINITION:
        return makeInterfaceDef(def);
      case _kinds.ENUM_DEFINITION:
        return makeEnumDef(def);
      case _kinds.UNION_DEFINITION:
        return makeUnionDef(def);
      case _kinds.SCALAR_DEFINITION:
        return makeScalarDef(def);
      case _kinds.INPUT_OBJECT_DEFINITION:
        return makeInputObjectDef(def);
      default:
        throw new Error(def.kind + ' not supported');
    }
  }

  function makeTypeDef(def) {
    var typeName = def.name.value;
    var config = {
      name: typeName,
      fields: function fields() {
        return makeFieldDefMap(def);
      },
      interfaces: function interfaces() {
        return makeImplementedInterfaces(def);
      }
    };
    return new _type.GraphQLObjectType(config);
  }

  function makeFieldDefMap(def) {
    return makeDict(def.fields, function (field) {
      return field.name.value;
    }, function (field) {
      return {
        type: produceTypeDef(field.type),
        args: makeArgs(field.arguments)
      };
    });
  }

  function makeImplementedInterfaces(def) {
    return def.interfaces.map(function (inter) {
      return produceTypeDef(inter);
    });
  }

  function makeArgs(args) {
    return makeDict(args, function (arg) {
      return arg.name.value;
    }, function (arg) {
      var type = produceTypeDef(arg.type);
      return {
        type: type,
        defaultValue: (0, _executorValues.coerceValueAST)(type, arg.defaultValue)
      };
    });
  }

  function makeInterfaceDef(def) {
    var typeName = def.name.value;
    var config = {
      name: typeName,
      fields: function fields() {
        return makeFieldDefMap(def);
      }
    };
    return new _type.GraphQLInterfaceType(config);
  }

  function makeEnumDef(def) {
    var enumType = new _type.GraphQLEnumType({
      name: def.name.value,
      values: makeDict(def.values, function (v) {
        return v.name.value;
      }, function () {
        return {};
      })
    });

    return enumType;
  }

  function makeUnionDef(def) {
    return new _type.GraphQLUnionType({
      name: def.name.value,
      types: def.types.map(function (t) {
        return produceTypeDef(t);
      })
    });
  }

  function makeScalarDef(def) {
    return new _type.GraphQLScalarType({
      name: def.name.value
    });
  }

  function makeInputObjectDef(def) {
    return new _type.GraphQLInputObjectType({
      name: def.name.value,
      fields: function fields() {
        return makeInputFieldDefMap(def);
      }
    });
  }

  function makeInputFieldDefMap(def) {
    return makeDict(def.fields, function (field) {
      return field.name.value;
    }, function (field) {
      return { type: produceTypeDef(field.type) };
    });
  }
}